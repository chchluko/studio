/**
 * This ruleset is designed for a voting application.
 *
 * Key Security Principles:
 * 1. Public Read on Candidates: All users, authenticated or not, can view the list of candidates. This is essential for the voting interface.
 * 2. Admin-Only Writes on Candidates: To maintain data integrity, only admin-level users (or server-side processes with admin privileges) should create, update, or delete candidates. Client-side writes are disabled.
 * 3. Authenticated-Only Voting: Only signed-in users can cast a vote. This prevents anonymous, untraceable voting.
 * 4. Vote Immutability: Once a vote is cast, it cannot be updated or deleted by the client. This ensures the integrity of the election results.
 * 5. Vote Ownership & Privacy: A user can only create a vote for themselves (`voterId` must match `request.auth.uid`). They can read their own vote but cannot read other users' votes, protecting the 'reason' field and preventing users from seeing who voted for whom.
 * 6. Preventing Double-Voting: The most critical rule. Before a vote is created, the rules check if a vote from that user already exists in the `votes` collection. The `exists()` function is used to perform this check, ensuring a user can only vote once.
 * 7. Photo Uploads: Users are allowed to update their own `photoUrl` in their candidate document, but no other fields.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // A user has not voted yet if no document in the 'votes' collection
    // has a 'voterId' field matching their user ID.
    function hasNotVoted() {
      return !exists(/databases/$(database)/documents/votes/$(request.auth.uid));
    }
    
    // A user has not voted yet if no document in the 'votes' collection
    // has a 'voterId' field matching their user ID. This is an alternative check.
    function canVote() {
        return isSignedIn() && getAfter(/databases/$(database)/documents/votes/$(request.auth.uid)) == null;
    }


    match /candidates/{candidateId} {
      // Anyone can read the list of candidates.
      allow read: if true;

      // Only an authenticated user can update their own photoUrl.
      // They cannot change any other field.
      allow update: if isSignedIn()
                      && request.auth.uid == candidateId
                      && request.resource.data.keys().hasOnly(['photoUrl', 'name', 'role', 'id', 'photoHint']);

      // Creating and deleting candidates should be an admin-only operation,
      // so it's disallowed on the client.
      allow create, delete: if false;
    }

    match /votes/{voteId} {
      // A user can read their own vote, but not list all votes.
      allow get: if isOwner(resource.data.voterId);
      allow list: if false;

      // A signed-in user can create a vote if:
      // 1. They are creating the vote for themselves (voterId matches their uid).
      // 2. They have not already voted. We check this by seeing if a document
      //    with their UID as the ID already exists in the 'votes' collection.
      //    To make this work, the client should set the vote document ID to the user's UID.
      allow create: if isSignedIn() && request.resource.data.voterId == request.auth.uid && hasNotVoted();

      // Votes are immutable.
      allow update, delete: if false;
    }

     match /users/{userId} {
      /**
       * @description A user's private voter status document.
       * @path /users/{userId}/voters/{voterId}
       * @allow (create) A user can create their own voter status document (`/users/abc/voters/abc`).
       * @deny (get) A user cannot read another user's voter status (`/users/xyz/voters/xyz`).
       * @principle Restricts access to a user's own data tree (Ownership).
       */
      match /voters/{voterId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);

        // A user can create their own voter document. The voterId in the path must match the userId.
        // Also enforces that the internal userId field is set correctly.
        allow create: if isOwner(userId) && userId == voterId && request.resource.data.userId == userId;
        
        // The owner can update their voter document (e.g., setting hasVoted=true in a transaction).
        // The userId field must remain immutable.
        allow update: if isOwner(userId) && resource != null && request.resource.data.userId == resource.data.userId;
        
        // The owner can delete their voter document.
        allow delete: if isOwner(userId) && resource != null;
      }
    }
  }
}
